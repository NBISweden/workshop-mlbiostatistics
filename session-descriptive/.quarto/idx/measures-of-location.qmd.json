{"title":"Measures of location","markdown":{"yaml":{"output":"html_document","editor_options":{"chunk_output_type":"console"}},"headingText":"Measures of location","containsRefs":false,"markdown":"\n\n```{r, include=T, message=FALSE, warning=FALSE}\n# load libraries\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(kableExtra)\nlibrary(faraway)\nlibrary(ggbeeswarm)\nlibrary(gridExtra)\nlibrary(reshape2)\n\n# define generic ggplot theme\nfont.size <- 12\ncol.blue.light <- \"#a6cee3\"\ncol.blue.dark <- \"#1f78b4\"\nmy.ggtheme <- theme(axis.title = element_text(size = font.size), \n        axis.text = element_text(size = font.size), \n        legend.text = element_text(size = font.size), \n        legend.title = element_blank(), \n        legend.position = \"top\", \n        axis.title.y = element_text(angle = 0)) \n\n# add obesity and diabetes status to diabetes faraway data\ninch2m <- 2.54/100\npound2kg <- 0.45\ndata_diabetes <- diabetes %>%\n  mutate(height  = height * inch2m, height = round(height, 2)) %>% \n  mutate(waist = waist * inch2m) %>%  \n  mutate(weight = weight * pound2kg, weight = round(weight, 2)) %>%\n  mutate(BMI = weight / height^2, BMI = round(BMI, 2)) %>% \n  mutate(obese= cut(BMI, breaks = c(0, 29.9, 100), labels = c(\"No\", \"Yes\"))) %>% \n  mutate(diabetic = ifelse(glyhb > 7, \"Yes\", \"No\"), diabetic = factor(diabetic, levels = c(\"No\", \"Yes\"))) %>%\n  na.omit()\n```\n\nIt is not always easy to get a \"feeling\" for a set of numerical measurements unless we summarize the data in a meaningful way. Diagrams, as shown in the previous chapter, are often a good starting point. We can further condense the information by reporting what constitutes a representative value. If we also know how widely scattered the observations are around it, we can formulate an image of data. The **average** is a general term for a measure of **location** and some common ways of calculating the average are mode, mean and median. \n\n## Mode\nMode values is the value that most common occurs across the measurements. It can be found for **numerical and categorical** data types. \n\nFor instance, we can find `age` mode value by counting how many times we observe each age value among the study participants. The mode values is the most commonly occurring one, here 63, with 9 participants being 63 at the time of the study. \n\n```{r}\n#| label: tbl-mode-age\n#| tbl-cap: Top three most observed age values among the study participants.\n#| tbl-cap-location: bottom\ndata_diabetes %>%\n  group_by(age) %>%\n  tally() %>%\n  arrange(desc(n)) %>%\n  slice(1:3) %>%\n  kbl() %>%\n  kable_styling()\n```\n\nAnalogously, we can find mode value for the categorical `diabetic status` by counting how many of the participants are diabetic and how many are not. Here, the mode is `No` with 100 study participants having glycosolated hemoglobin level lower than 7.0 and 30 above. \n\n```{r}\n#| label: tbl-mode-obese\n#| tbl-cap: Number of times diabetic status of No and Yes is observed for the study participants.\n#| tbl-cap-location: bottom\ndata_diabetes %>%\n  group_by(diabetic) %>%\n  tally() %>%\n  arrange(desc(n)) %>%\n  slice(1:3) %>%\n  kbl %>%\n  kable_styling()\n```\n\n\n## Median \nMedian value divides the **ordered** data values into two equally sized groups so that 50% of the values are below and 50% are above the median value. For the odd number of observations, the middle value is $(n+1)/2$-th term of the ordered observations. For even number of observations, it is the average of the middle two terms of the ordered observations.\n\n\\begin{equation}\n    Median =\n    \\left\\{\n        \\begin{array}{cc}\n                \\frac{(n+1)}{2}^{th} term & \\mathrm{if\\ } n \\mathrm{\\ is\\ odd} \\\\\n                \\frac{1}{2}\\times \\left (\\frac{n}{2}^{th} term + (\\frac{n}{2}+1)^{th} term \\right) & \\mathrm{if\\ } n \\mathrm{\\ is\\ even}  \\\\\n        \\end{array}\n    \\right.\n\\end{equation} \n\nFor instance, the median value for `age` for the first 10 study participants:\n```{r}\n#| results: asis\n#| tbl-cap: Age values for the first 10 study participants.\n#| tbl-cap-location: margin\nage_10 <- data_diabetes %>%\n  slice(1:10)  # select first 10 participants\n\n# show age for 10 first participants\nage_10 %>%\n  select(id, age) %>% \n  pivot_wider(names_from = id, values_from = age) %>%\n  kbl() %>%\n  kable_styling() \n\n```\ncan be found by ordering observations: \n```{r}\nage_10_ordered <- data_diabetes %>%\n  slice(1:10) %>% # select first 10 participants\n  arrange(age) %>% # order by age\n  pull(age) # extract ordered age observations\n\ndata_diabetes %>%\n  slice(1:10) %>% # select first 10 participants\n  arrange(age) %>%\n  select(id, age) %>% \n  pivot_wider(names_from = id, values_from = age) %>%\n  kbl() %>%\n  kable_styling() %>%\n  column_spec(c(5), background = \"gold\") %>%\n  column_spec(c(6), background = \"gold\")\n\n\n```\n\nand averaging $5^{th}$ and $6^{th}$ term in the ordered observations giving a median value of: \n```{r}\n#| code-fold: false\n1/2*(age_10_ordered[5] + age_10_ordered[6])\n```\n\nThe median value for `age` for the first 11 study participants:\n```{r}\n#| results: asis\n#| tbl-cap: Age values for the first 10 study participants.\n#| tbl-cap-location: margin\nage_11 <- data_diabetes %>%\n  slice(1:11)  # select first 11 participants\n\n# show age for 10 first participants\nage_11 %>%\n  select(id, age) %>% \n  pivot_wider(names_from = id, values_from = age) %>%\n  kbl() %>%\n  kable_styling() \n\n```\n\ncan be found by taking $6^{th}$ term from the ordered observations: \n```{r}\nage_11_ordered <- data_diabetes %>%\n  slice(1:11) %>% # select first 11 participants\n  arrange(age) %>% # order by age\n  pull(age) # extract ordered age observations\n\ndata_diabetes %>%\n  slice(1:11) %>% # select first 11 participants\n  arrange(age) %>%\n  select(id, age) %>% \n  pivot_wider(names_from = id, values_from = age) %>%\n  kbl() %>%\n  kable_styling() %>%\n  column_spec(c(6), background = \"gold\")\n\n```\n\ngiving a median value of: \n```{r}\n#| code-fold: false\nage_11_ordered[6]\n```\n\nAlternatively, we can use `median()` function to check our calculations:\n```{r}\n#| code-fold: false\n#| collapse: true\ndata_diabetes %>%\n  dplyr::slice(1:10) %$%\n  median(age)\n\ndata_diabetes %>%\n  dplyr::slice(1:11) %$%\n  median(age)\n\n```\n\n\n## Arthimetic mean\n**The arithmetic mean**, also commonly referred to as  **mean**, is calculated by adding up all the values and diving the sum by the number of values in the data set.\n\nMathematically, for $n$ observations $x_1, x_2, \\dots, x_n$, the arithmetic mean value is calculated as:\n$$\\bar x = \\frac{x_1+x_2+\\dots+x_n}{n} = \\frac{1}{n}\\displaystyle\\sum_{i=1}^n x_i$$ {#eq-mean}\n\nTo calculate the arithmetic mean for `BMI` given our 130 study participants we can follow @eq-mean\n\n```{r}\n#| code-fold: false\n\n# calculate arithmetic mean following the equation\nx <- data_diabetes %>%\n  pull(BMI) # extract BMI observations\nn <- length(x) # number of observations\nx.bar <- sum(x) / n # calculate mean\nprint(x.bar)\n\nBMI_mean <- round(x.bar, 2)\n```\n\nor use basic `mean()` function in R:\n\n```{r}\n#| code-fold: false\ndata_diabetes %$%\n  mean(BMI) %>%\n  print()\n```\n\n## Weighted mean\n\nAs all the values equally contribute to the calculations, the arithmetic mean value is easily affected by outliers and is distorted by skewed distributions. Sometimes, the **weighted mean** may be more useful, as it allows add weights to certain values of the variable of interest. We attach a weight, $w_i$ to each of the observed values, $x_i$, in our sample, to reflect this importance and define the weighted mean as: $$\\bar{x} = \\frac{w_1x_1 + w_2x_2 + \\ldots + w_nx_n}{w_1 + w_2 + \\ldots + w_n} = \\frac{\\displaystyle\\sum_{i=1}^{n}w_ix_i}{\\displaystyle\\sum_{i=1}^{n}w_i}$$ {#eq-mean-weighted}\n\nFor instance, we may be interested in knowing an average `BMI` value, irrespective of `gender`. It happens that among our study participants women are over represented: \n\n```{r}\n#| tbl-cap: Number of male and female study participans.\n#| tbl-cap-location: margin\n#| code-fold: true\n#| collapse: false\n\ndata_diabetes %>%\n  group_by(gender) %>%\n  tally() %>%\n  kbl() %>%\n  kable_styling()\n\n```\n\nAssuming BMI measurements for men and women should have equal influence (50/50), we can calculate `weighted BMI` mean to account for group sizes. We assign weights to BMI observations for men and women so that they sum up to 100. Since we have 73 measurements for women, the corresponding weights are $w_f = 50 / 73 = 0.6849315$ and $w_m = 50 / 57 = 0.877193$ for measurements reported for men. The weighted mean can now be calculated following @eq-mean-weighted and is equal to:\n\n```{r}\n#| code-fold: false\n\n\n# number of women\nn_w <- data_diabetes%>%\n  filter(gender == \"female\") %>%\n  nrow()\n\n# number of men\nn_m <- data_diabetes%>%\n  filter(gender == \"male\") %>%\n  nrow()\n\n# add weights to observations\ndata_diabetes_addweights <- data_diabetes %>%\n  mutate(w = ifelse(gender == \"male\", 50/n_m, 50/n_w)) %>% # assign weights\n  mutate(wx = BMI * w)  # multiply weight by their weights values\n  \nnumerator <- data_diabetes_addweights %$%\n  sum(wx)\n\ndenominator <- data_diabetes_addweights %$%\n  sum(w)\n\nBMI_weighted_mean <- numerator / denominator\n  \nBMI_weighted_mean <- BMI_weighted_mean %>%\n  round(2) %>%\n  print()\n\n```\n\n\nWe previously calculated BMI mean of `r BMI_mean` and mean BMI for men and women are:\n```{r}\n#| tbl-cap: Mean BMI values for men and women in the study.\n#| tbl-cap-location: margin\n\ndata_diabetes %>%\n  group_by(gender) %>%\n  summarize(mean_BMI = mean(BMI)) %>%\n  kbl(digits = 2) %>%\n  kable_styling()\n\n```\n\nWe can note, as expected, that the weighted mean of BMI `r BMI_weighted_mean` is shifted slightly towards mean BMI for men since the BMI measurements for men have been assigned higher weights to account for women being overrepresented in the study. \n\n## Mean, median & outliers\n\nMedian is usually preferred when data has outliers as it follows from median definition that is less sensitive to outliers. On the other hand, mean value can be distorted when outliers are present. Let's add an outlying value of age (110) to the first 11 study participants, and re-calculate mean and median. \n\n```{r}\n#| tbl-cap: Comparision of mean and median age values before and after adding outlying age value of 110 to the first 11 study participants.\n#| tbl-cap-location: margin\n\n# pull age values for the first 11 study participants\nage_11 <- data_diabetes %>%\n  slice(1:11) %>%\n  select(id, age) %>%\n  pull(age)\n  \n# add outlier value of 110\nage_11_with_outlier <- c(age_11, 110)\n\n# calculate mean and median, with and without outlier\n\n# without outlier\nage_mean_without <- mean(age_11) %>% round(2)\nage_median_without <- median(age_11)\n\n# with outlier\nage_mean_with <- mean(age_11_with_outlier) %>% round(2)\nage_median_with <- median(age_11_with_outlier)\n\nres <- data.frame(mean = c(age_mean_without, age_mean_with), \n                  median = c(age_median_without, age_median_with), \n                  row.names = c(\"without outlier\", \"with outlier\"))\n\nres %>%\n  kbl() %>%\n  kable_styling()\n```\n\nWe can see that adding one outlying age value shifted mean age from `r age_mean_without` to `r age_mean_with` while median age value did not change that much with original median value being `r age_median_without` and `r age_median_with` after adding the outlying value.\n\nIn addition, it is good to remember that several very different distributions can still have the same mean value.\n\n```{r mean35, warning=FALSE, message=FALSE, include=T, echo=F}\n#| fig-cap: Examples of various distributions having the same mean value of 3.5\n#| label: fig-mean-distr\n#| fig-width: 12\n#| fig-height: 10\n#| fig-cap-location: margin\n\ndf <- data.frame(x=rnorm(200, 3.5, 2))\ndf$x <- df$x - mean(df$x) + 3.5\ny <- exp(rnorm(200, 0, 1))\ny <- y+3.5 - mean(y)\ndf$y=y\n\ndf$z <- rep(c(0,10), c(200*.65, 200*.35))\n\ndf$a <- rnorm(200, 3.5, 8)\ndf$a <- df$a - mean(df$a) + 3.5\nb <- exp(rnorm(200, 2, 1))\ndf$b <- b+3.5 - mean(b)\nc <- c(rnorm(150, 10, 3), rnorm(50,0,1))\nc <- c + 3.5 - mean(c)\ndf$c <- c\n\ndata.plot <- df\ncolnames(data.plot) <- c(\"Distr1\", \"Distr2\", \"Distr3\", \"Distr4\", \"Distr5\", \"Distr6\")\ndata.plot %>%\n  rownames_to_column(\"x\") %>%\n  pivot_longer(-x, names_to = \"Distr\") %>%\n  ggplot(aes(x = value)) +\n  geom_histogram(color=\"white\", bins=30) +\n  facet_wrap(~Distr, scale = \"free\") +\n  theme_bw() +\n  xlab(\"\")\n\n```\n\n\n\n\n\n\n## More averages\n\nBeyond the common averages measure above, there is many more that one may encounter. **The trimmed mean** reduces the influence of outliers by removing a specified percentage of extreme values before calculating the mean, making it valuable in clinical trials where extreme results may skew data. **The geometric mean** is crucial in pharmacokinetics for calculating average rates of drug absorption or clearance, as it computes the nth root of the product of all data points. **The moving average** is commonly used in epidemiology to smooth out daily case reports of diseases, helping to visualize trends by averaging data points within a sliding window over time. **The Hodges-Lehmann estimator**, a robust statistic for central tendency, is less affected by outliers. It calculates the median of all possible averages of sample pairs, ideal for non-parametric analyses in studies where data may not be normally distributed, such as environmental exposure assessments\n\n**Trimmed Mean**\n\n$$\\text{Trimmed Mean} = \\frac{\\sum_{i=p+1}^{n-p} x_{(i)}}{n - 2p}$$\nHere, $x_{(i)}$ are the ordered observations from smallest to largest, $n$ is the total number of observations, and $p$ is the number of extreme values removed from each end of the dataset.\n\n**Geometric Mean**\n$$\\text{Geometric Mean (GM)} = \\left(\\prod_{i=1}^{n} x_i\\right)^{1/n}$$\nThe geometric mean is the nth root of the product of all $n$ data points, $x_i$.\n\n**Moving Average**\n$$\\text{Moving Average} = \\frac{1}{k} \\sum_{i=j}^{j+k-1} x_i$$\nThis averages $k$ consecutive data points in a series, starting from point $j$.\n\n**Hodges-Lehmann Estimator**\n$$\\text{Hodges-Lehmann Estimator} = \\text{Median} \\left( \\frac{x_i + x_j}{2} \\right)$$\nThis estimator is calculated by taking all possible pairs $(x_i, x_j)$ of sample observations, computing their average, and then finding the median of these averages.\n\n","srcMarkdownNoYaml":"\n\n# Measures of location\n```{r, include=T, message=FALSE, warning=FALSE}\n# load libraries\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(kableExtra)\nlibrary(faraway)\nlibrary(ggbeeswarm)\nlibrary(gridExtra)\nlibrary(reshape2)\n\n# define generic ggplot theme\nfont.size <- 12\ncol.blue.light <- \"#a6cee3\"\ncol.blue.dark <- \"#1f78b4\"\nmy.ggtheme <- theme(axis.title = element_text(size = font.size), \n        axis.text = element_text(size = font.size), \n        legend.text = element_text(size = font.size), \n        legend.title = element_blank(), \n        legend.position = \"top\", \n        axis.title.y = element_text(angle = 0)) \n\n# add obesity and diabetes status to diabetes faraway data\ninch2m <- 2.54/100\npound2kg <- 0.45\ndata_diabetes <- diabetes %>%\n  mutate(height  = height * inch2m, height = round(height, 2)) %>% \n  mutate(waist = waist * inch2m) %>%  \n  mutate(weight = weight * pound2kg, weight = round(weight, 2)) %>%\n  mutate(BMI = weight / height^2, BMI = round(BMI, 2)) %>% \n  mutate(obese= cut(BMI, breaks = c(0, 29.9, 100), labels = c(\"No\", \"Yes\"))) %>% \n  mutate(diabetic = ifelse(glyhb > 7, \"Yes\", \"No\"), diabetic = factor(diabetic, levels = c(\"No\", \"Yes\"))) %>%\n  na.omit()\n```\n\nIt is not always easy to get a \"feeling\" for a set of numerical measurements unless we summarize the data in a meaningful way. Diagrams, as shown in the previous chapter, are often a good starting point. We can further condense the information by reporting what constitutes a representative value. If we also know how widely scattered the observations are around it, we can formulate an image of data. The **average** is a general term for a measure of **location** and some common ways of calculating the average are mode, mean and median. \n\n## Mode\nMode values is the value that most common occurs across the measurements. It can be found for **numerical and categorical** data types. \n\nFor instance, we can find `age` mode value by counting how many times we observe each age value among the study participants. The mode values is the most commonly occurring one, here 63, with 9 participants being 63 at the time of the study. \n\n```{r}\n#| label: tbl-mode-age\n#| tbl-cap: Top three most observed age values among the study participants.\n#| tbl-cap-location: bottom\ndata_diabetes %>%\n  group_by(age) %>%\n  tally() %>%\n  arrange(desc(n)) %>%\n  slice(1:3) %>%\n  kbl() %>%\n  kable_styling()\n```\n\nAnalogously, we can find mode value for the categorical `diabetic status` by counting how many of the participants are diabetic and how many are not. Here, the mode is `No` with 100 study participants having glycosolated hemoglobin level lower than 7.0 and 30 above. \n\n```{r}\n#| label: tbl-mode-obese\n#| tbl-cap: Number of times diabetic status of No and Yes is observed for the study participants.\n#| tbl-cap-location: bottom\ndata_diabetes %>%\n  group_by(diabetic) %>%\n  tally() %>%\n  arrange(desc(n)) %>%\n  slice(1:3) %>%\n  kbl %>%\n  kable_styling()\n```\n\n\n## Median \nMedian value divides the **ordered** data values into two equally sized groups so that 50% of the values are below and 50% are above the median value. For the odd number of observations, the middle value is $(n+1)/2$-th term of the ordered observations. For even number of observations, it is the average of the middle two terms of the ordered observations.\n\n\\begin{equation}\n    Median =\n    \\left\\{\n        \\begin{array}{cc}\n                \\frac{(n+1)}{2}^{th} term & \\mathrm{if\\ } n \\mathrm{\\ is\\ odd} \\\\\n                \\frac{1}{2}\\times \\left (\\frac{n}{2}^{th} term + (\\frac{n}{2}+1)^{th} term \\right) & \\mathrm{if\\ } n \\mathrm{\\ is\\ even}  \\\\\n        \\end{array}\n    \\right.\n\\end{equation} \n\nFor instance, the median value for `age` for the first 10 study participants:\n```{r}\n#| results: asis\n#| tbl-cap: Age values for the first 10 study participants.\n#| tbl-cap-location: margin\nage_10 <- data_diabetes %>%\n  slice(1:10)  # select first 10 participants\n\n# show age for 10 first participants\nage_10 %>%\n  select(id, age) %>% \n  pivot_wider(names_from = id, values_from = age) %>%\n  kbl() %>%\n  kable_styling() \n\n```\ncan be found by ordering observations: \n```{r}\nage_10_ordered <- data_diabetes %>%\n  slice(1:10) %>% # select first 10 participants\n  arrange(age) %>% # order by age\n  pull(age) # extract ordered age observations\n\ndata_diabetes %>%\n  slice(1:10) %>% # select first 10 participants\n  arrange(age) %>%\n  select(id, age) %>% \n  pivot_wider(names_from = id, values_from = age) %>%\n  kbl() %>%\n  kable_styling() %>%\n  column_spec(c(5), background = \"gold\") %>%\n  column_spec(c(6), background = \"gold\")\n\n\n```\n\nand averaging $5^{th}$ and $6^{th}$ term in the ordered observations giving a median value of: \n```{r}\n#| code-fold: false\n1/2*(age_10_ordered[5] + age_10_ordered[6])\n```\n\nThe median value for `age` for the first 11 study participants:\n```{r}\n#| results: asis\n#| tbl-cap: Age values for the first 10 study participants.\n#| tbl-cap-location: margin\nage_11 <- data_diabetes %>%\n  slice(1:11)  # select first 11 participants\n\n# show age for 10 first participants\nage_11 %>%\n  select(id, age) %>% \n  pivot_wider(names_from = id, values_from = age) %>%\n  kbl() %>%\n  kable_styling() \n\n```\n\ncan be found by taking $6^{th}$ term from the ordered observations: \n```{r}\nage_11_ordered <- data_diabetes %>%\n  slice(1:11) %>% # select first 11 participants\n  arrange(age) %>% # order by age\n  pull(age) # extract ordered age observations\n\ndata_diabetes %>%\n  slice(1:11) %>% # select first 11 participants\n  arrange(age) %>%\n  select(id, age) %>% \n  pivot_wider(names_from = id, values_from = age) %>%\n  kbl() %>%\n  kable_styling() %>%\n  column_spec(c(6), background = \"gold\")\n\n```\n\ngiving a median value of: \n```{r}\n#| code-fold: false\nage_11_ordered[6]\n```\n\nAlternatively, we can use `median()` function to check our calculations:\n```{r}\n#| code-fold: false\n#| collapse: true\ndata_diabetes %>%\n  dplyr::slice(1:10) %$%\n  median(age)\n\ndata_diabetes %>%\n  dplyr::slice(1:11) %$%\n  median(age)\n\n```\n\n\n## Arthimetic mean\n**The arithmetic mean**, also commonly referred to as  **mean**, is calculated by adding up all the values and diving the sum by the number of values in the data set.\n\nMathematically, for $n$ observations $x_1, x_2, \\dots, x_n$, the arithmetic mean value is calculated as:\n$$\\bar x = \\frac{x_1+x_2+\\dots+x_n}{n} = \\frac{1}{n}\\displaystyle\\sum_{i=1}^n x_i$$ {#eq-mean}\n\nTo calculate the arithmetic mean for `BMI` given our 130 study participants we can follow @eq-mean\n\n```{r}\n#| code-fold: false\n\n# calculate arithmetic mean following the equation\nx <- data_diabetes %>%\n  pull(BMI) # extract BMI observations\nn <- length(x) # number of observations\nx.bar <- sum(x) / n # calculate mean\nprint(x.bar)\n\nBMI_mean <- round(x.bar, 2)\n```\n\nor use basic `mean()` function in R:\n\n```{r}\n#| code-fold: false\ndata_diabetes %$%\n  mean(BMI) %>%\n  print()\n```\n\n## Weighted mean\n\nAs all the values equally contribute to the calculations, the arithmetic mean value is easily affected by outliers and is distorted by skewed distributions. Sometimes, the **weighted mean** may be more useful, as it allows add weights to certain values of the variable of interest. We attach a weight, $w_i$ to each of the observed values, $x_i$, in our sample, to reflect this importance and define the weighted mean as: $$\\bar{x} = \\frac{w_1x_1 + w_2x_2 + \\ldots + w_nx_n}{w_1 + w_2 + \\ldots + w_n} = \\frac{\\displaystyle\\sum_{i=1}^{n}w_ix_i}{\\displaystyle\\sum_{i=1}^{n}w_i}$$ {#eq-mean-weighted}\n\nFor instance, we may be interested in knowing an average `BMI` value, irrespective of `gender`. It happens that among our study participants women are over represented: \n\n```{r}\n#| tbl-cap: Number of male and female study participans.\n#| tbl-cap-location: margin\n#| code-fold: true\n#| collapse: false\n\ndata_diabetes %>%\n  group_by(gender) %>%\n  tally() %>%\n  kbl() %>%\n  kable_styling()\n\n```\n\nAssuming BMI measurements for men and women should have equal influence (50/50), we can calculate `weighted BMI` mean to account for group sizes. We assign weights to BMI observations for men and women so that they sum up to 100. Since we have 73 measurements for women, the corresponding weights are $w_f = 50 / 73 = 0.6849315$ and $w_m = 50 / 57 = 0.877193$ for measurements reported for men. The weighted mean can now be calculated following @eq-mean-weighted and is equal to:\n\n```{r}\n#| code-fold: false\n\n\n# number of women\nn_w <- data_diabetes%>%\n  filter(gender == \"female\") %>%\n  nrow()\n\n# number of men\nn_m <- data_diabetes%>%\n  filter(gender == \"male\") %>%\n  nrow()\n\n# add weights to observations\ndata_diabetes_addweights <- data_diabetes %>%\n  mutate(w = ifelse(gender == \"male\", 50/n_m, 50/n_w)) %>% # assign weights\n  mutate(wx = BMI * w)  # multiply weight by their weights values\n  \nnumerator <- data_diabetes_addweights %$%\n  sum(wx)\n\ndenominator <- data_diabetes_addweights %$%\n  sum(w)\n\nBMI_weighted_mean <- numerator / denominator\n  \nBMI_weighted_mean <- BMI_weighted_mean %>%\n  round(2) %>%\n  print()\n\n```\n\n\nWe previously calculated BMI mean of `r BMI_mean` and mean BMI for men and women are:\n```{r}\n#| tbl-cap: Mean BMI values for men and women in the study.\n#| tbl-cap-location: margin\n\ndata_diabetes %>%\n  group_by(gender) %>%\n  summarize(mean_BMI = mean(BMI)) %>%\n  kbl(digits = 2) %>%\n  kable_styling()\n\n```\n\nWe can note, as expected, that the weighted mean of BMI `r BMI_weighted_mean` is shifted slightly towards mean BMI for men since the BMI measurements for men have been assigned higher weights to account for women being overrepresented in the study. \n\n## Mean, median & outliers\n\nMedian is usually preferred when data has outliers as it follows from median definition that is less sensitive to outliers. On the other hand, mean value can be distorted when outliers are present. Let's add an outlying value of age (110) to the first 11 study participants, and re-calculate mean and median. \n\n```{r}\n#| tbl-cap: Comparision of mean and median age values before and after adding outlying age value of 110 to the first 11 study participants.\n#| tbl-cap-location: margin\n\n# pull age values for the first 11 study participants\nage_11 <- data_diabetes %>%\n  slice(1:11) %>%\n  select(id, age) %>%\n  pull(age)\n  \n# add outlier value of 110\nage_11_with_outlier <- c(age_11, 110)\n\n# calculate mean and median, with and without outlier\n\n# without outlier\nage_mean_without <- mean(age_11) %>% round(2)\nage_median_without <- median(age_11)\n\n# with outlier\nage_mean_with <- mean(age_11_with_outlier) %>% round(2)\nage_median_with <- median(age_11_with_outlier)\n\nres <- data.frame(mean = c(age_mean_without, age_mean_with), \n                  median = c(age_median_without, age_median_with), \n                  row.names = c(\"without outlier\", \"with outlier\"))\n\nres %>%\n  kbl() %>%\n  kable_styling()\n```\n\nWe can see that adding one outlying age value shifted mean age from `r age_mean_without` to `r age_mean_with` while median age value did not change that much with original median value being `r age_median_without` and `r age_median_with` after adding the outlying value.\n\nIn addition, it is good to remember that several very different distributions can still have the same mean value.\n\n```{r mean35, warning=FALSE, message=FALSE, include=T, echo=F}\n#| fig-cap: Examples of various distributions having the same mean value of 3.5\n#| label: fig-mean-distr\n#| fig-width: 12\n#| fig-height: 10\n#| fig-cap-location: margin\n\ndf <- data.frame(x=rnorm(200, 3.5, 2))\ndf$x <- df$x - mean(df$x) + 3.5\ny <- exp(rnorm(200, 0, 1))\ny <- y+3.5 - mean(y)\ndf$y=y\n\ndf$z <- rep(c(0,10), c(200*.65, 200*.35))\n\ndf$a <- rnorm(200, 3.5, 8)\ndf$a <- df$a - mean(df$a) + 3.5\nb <- exp(rnorm(200, 2, 1))\ndf$b <- b+3.5 - mean(b)\nc <- c(rnorm(150, 10, 3), rnorm(50,0,1))\nc <- c + 3.5 - mean(c)\ndf$c <- c\n\ndata.plot <- df\ncolnames(data.plot) <- c(\"Distr1\", \"Distr2\", \"Distr3\", \"Distr4\", \"Distr5\", \"Distr6\")\ndata.plot %>%\n  rownames_to_column(\"x\") %>%\n  pivot_longer(-x, names_to = \"Distr\") %>%\n  ggplot(aes(x = value)) +\n  geom_histogram(color=\"white\", bins=30) +\n  facet_wrap(~Distr, scale = \"free\") +\n  theme_bw() +\n  xlab(\"\")\n\n```\n\n\n\n\n\n\n## More averages\n\nBeyond the common averages measure above, there is many more that one may encounter. **The trimmed mean** reduces the influence of outliers by removing a specified percentage of extreme values before calculating the mean, making it valuable in clinical trials where extreme results may skew data. **The geometric mean** is crucial in pharmacokinetics for calculating average rates of drug absorption or clearance, as it computes the nth root of the product of all data points. **The moving average** is commonly used in epidemiology to smooth out daily case reports of diseases, helping to visualize trends by averaging data points within a sliding window over time. **The Hodges-Lehmann estimator**, a robust statistic for central tendency, is less affected by outliers. It calculates the median of all possible averages of sample pairs, ideal for non-parametric analyses in studies where data may not be normally distributed, such as environmental exposure assessments\n\n**Trimmed Mean**\n\n$$\\text{Trimmed Mean} = \\frac{\\sum_{i=p+1}^{n-p} x_{(i)}}{n - 2p}$$\nHere, $x_{(i)}$ are the ordered observations from smallest to largest, $n$ is the total number of observations, and $p$ is the number of extreme values removed from each end of the dataset.\n\n**Geometric Mean**\n$$\\text{Geometric Mean (GM)} = \\left(\\prod_{i=1}^{n} x_i\\right)^{1/n}$$\nThe geometric mean is the nth root of the product of all $n$ data points, $x_i$.\n\n**Moving Average**\n$$\\text{Moving Average} = \\frac{1}{k} \\sum_{i=j}^{j+k-1} x_i$$\nThis averages $k$ consecutive data points in a series, starting from point $j$.\n\n**Hodges-Lehmann Estimator**\n$$\\text{Hodges-Lehmann Estimator} = \\text{Median} \\left( \\frac{x_i + x_j}{2} \\right)$$\nThis estimator is calculated by taking all possible pairs $(x_i, x_j)$ of sample observations, computing their average, and then finding the median of these averages.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":"html_document","warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","self-contained":false,"output-file":"measures-of-location.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","bibliography":["references.bib"],"theme":"cosmo","editor_options":{"chunk_output_type":"console"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}