{
  "hash": "491b7067279a57539228baad8da06d2e",
  "result": {
    "markdown": "---\noutput: html_document\neditor_options: \n  chunk_output_type: console\n---\n\n# Measures of spread\n\n::: {.cell}\n\n```{.r .cell-code}\n# load libraries\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(kableExtra)\nlibrary(faraway)\nlibrary(scales)\nlibrary(ggbeeswarm)\nlibrary(gridExtra)\n\n# define generic ggplot theme\nfont.size <- 12\ncol.blue.light <- \"#a6cee3\"\ncol.blue.dark <- \"#1f78b4\"\nmy.ggtheme <- theme(axis.title = element_text(size = font.size), \n        axis.text = element_text(size = font.size), \n        legend.text = element_text(size = font.size), \n        legend.title = element_blank(), \n        legend.position = \"top\", \n        axis.title.y = element_text(angle = 0)) \n\n# add obesity and diabetes status to diabetes faraway data\ninch2m <- 2.54/100\npound2kg <- 0.45\ndata_diabetes <- diabetes %>%\n  mutate(height  = height * inch2m, height = round(height, 2)) %>% \n  mutate(waist = waist * inch2m) %>%  \n  mutate(weight = weight * pound2kg, weight = round(weight, 2)) %>%\n  mutate(BMI = weight / height^2, BMI = round(BMI, 2)) %>% \n  mutate(obese= cut(BMI, breaks = c(0, 29.9, 100), labels = c(\"No\", \"Yes\"))) %>% \n  mutate(diabetic = ifelse(glyhb > 7, \"Yes\", \"No\"), diabetic = factor(diabetic, levels = c(\"No\", \"Yes\"))) %>%\n  na.omit()\n```\n:::\n\n\n## Range\nThe **range** is the difference between the largest and the smallest observations in the data set. Similar to mean, it can be a misleading measure if there are outliers in the data. \n\nGiven our age values the range can be calculated: \n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nage_max <- data_diabetes %$%\n  max(age)\n\nage_min <- data_diabetes %$%\n  min(age)\n\nrange <- age_max - age_min\nprint(range)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 69\n```\n:::\n:::\n\n\n\n## Quartiles \n\nIf we arrange the data in order of magnitude, starting with the smallest and ending with the largest value we can define percentiles. The value of $x$ that has 1% of the observations in the ordered set lying below it (and 99% of the observations lying above it) is called the 1st **percentile**. The value of $x$ that has 2% of the observations in the ordered set lying below it (and 98% of the observations lying above it) is called the 2nd percentile, and so on. The values of $x$ that divide the ordered set into 10 equally sized groups, that is the 10th, 20th, 30th, ..., 90th percentiles, are called **deciles**.\n\n**Quartiles** are the **three values** that divide the data values into **four equally sized groups**.\n\n  - **Q1**. Lower quartile. 25% of values are below Q1. Divides the values below the median into equally sized groups.\n  - **Q2**. **Median**. 50% of values are below Q2 and 50% are above Q2. Q2 is the median that we have seen before.\n  - **Q3**. Upper quartile. 75% of values are below Q3. Divides the values above the median into equally sized groups.\n\nGoing back to the diabetes data set, what are the three quartiles of participants age?\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# calculate quartiles\nquartiles <- data_diabetes %>%\n  reframe(x = quantile(age, c(0.25, 0.5, 0.75))) \n\nQ1 <- quartiles %>% slice(1) %>% pull(x)\nQ2 <- quartiles %>% slice(2) %>% pull(x)\nQ3 <- quartiles %>% slice(3) %>% pull(x)\n\nprint(Q1)\n## [1] 40\nprint(Q2)\n## [1] 51\nprint(Q3)\n## [1] 61.75\n```\n:::\n\n\n## IQR\nThe **interquartile range**, IQR, is the difference between the 1st (Q1) and the 3rd (Q3) quartiles, i.e. between the 25th and 75th percentiles. It contains the central 50% of the observations in the ordered set.\n\n$$IQR = Q3 - Q1$$\n\nFor instance, the IQR range for age value for our study is: \n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\niqr = Q3 - Q1\nprint(iqr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21.75\n```\n:::\n:::\n\n\n\n\n## Variance and standard deviation\n\nThe **variance** of a set of observations is their mean squared distance from the mean value:\n\n$$\\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\bar x)^2.$$ {#eq-sigma2}\n\n\n::: {.cell .fig-cap-location-margin}\n\n```{.r .cell-code}\ndata.xy <- data_diabetes %>%\n  slice(1:10) %>% \n  mutate(id = as.character(id)) %>%\n  rename(y = age) %>%\n  rename(x = id)\n\ny.bar <- mean(data.xy$y)\n\ndata.xy %>%\nggplot(aes(x=x, y=y)) +\n  geom_segment( aes(x=x, xend=x, y=y, yend=y.bar), color=\"grey\") +\n  geom_point(color=col.blue.dark, size=4) +\n  geom_hline(yintercept=y.bar) +\n  theme_bw() +\n  theme(\n    panel.grid.major.x = element_blank(),\n    panel.border = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.y = element_blank()) +\n  xlab(\"\") +\n  ylab(\"Age (year)\") +\n  coord_flip() +\n  my.ggtheme\n```\n\n::: {.cell-output-display}\n![First ten age measurements for the study participants. Grey lines show the distance to the age mean value.](measures-of-spread_files/figure-html/fig-var-1.png){#fig-var width=672}\n:::\n:::\n\n\n\nThe variance is measured in the square of the unit in which $x$ was measured. Another common measure using the same unit as $x$ is **standard deviation**, defined as the square root of the variance:\n\n$$\\sigma = \\sqrt{\\frac{1}{n} \\sum_{i=1}^n (x_i - \\bar x)^2}$$ {#eq-sigma}\n\nTypically, we regard the collection of observations $x_1, \\dots, x_n$ as a **sample** drawn from a large **population** of possible observations. It has been shown theoretically that we obtain a better sample estimate of the population variance and standard deviation if we divide by $(n-1)$. So the denominator $n$ is commonly replaced by $n-1$ and the **sample variance** is calculated instead as \n\n$$s^2 = {\\frac{1}{n-1} \\sum_{i=1}^n (x_i - \\bar x)^2}.$$ {#eq-s2}\n\nand the **sample standard deviation** is calculated as:\n\n$$s = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^n (x_i - \\bar x)^2}.$$ {#eq-s}\n\nTo reiterate:\n\n- we calculate standard deviation, $\\sigma$, when we consider our observations to be entire population (@eq-sigma)\n- we calculate sample standard deviation, $s$, when we consider our observations a random sample from a larger population, as a better estimate of the standard deviation of the larger population (@eq-s)\n\nLet's calculate variance, standard deviation and sample standard deviation for `age`.\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# extract age values\nage <- data_diabetes %>% pull(age)\n\n# number of observations\nn <- length(age)\n\n# calculate mean (arithmetic)\nage_mean <- mean(age)\n\n# calculate variance following variance equation\nsigma2 <- (sum((age - age_mean)^2))/(n)\n\n# calculate standard deviation following standard deviation equation\nsigma <- sqrt((sum((age - age_mean)^2))/(n))\n\n# calculate sample variance following sample variance equation\ns2 <- (sum((age - age_mean)^2))/(n-1)\n\n# calculate sample standard deviation following sample standard deviation equation\ns <- sqrt((sum((age - age_mean)^2))/(n-1))\n\n# collect results\nv.name <- c(\"sigma2\", \"sigma\", \"s2\", \"s\")\nv.values <- c(sigma2, sigma, s2, s)\nresults <- data.frame(stats = v.name, value = v.values)\nprint(results)\n##    stats     value\n## 1 sigma2 224.80828\n## 2  sigma  14.99361\n## 3     s2 226.55098\n## 4      s  15.05161\n```\n:::\n\n\nWe can check our calculations of sample variance and sample standard deviation using `R` functions `var()` and `sd()`\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nprint(var(age))\n## [1] 226.551\nprint(sd(age))\n## [1] 15.05161\n```\n:::\n",
    "supporting": [
      "measures-of-spread_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}