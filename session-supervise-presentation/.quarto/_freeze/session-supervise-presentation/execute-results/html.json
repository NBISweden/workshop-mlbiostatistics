{
  "hash": "80d360097f7234fec6ce562945ed3ed0",
  "result": {
    "markdown": "---\ntitle: \"Supervised learning\"\n# author: Olga Dethlefsen\nformat: \n  revealjs:\n    slide-number: true\n    theme: [default, custom.scss]\n    view-distance: 10\n    chalkboard: \n      buttons: true\n  html:\n    code-fold: false\neditor_options: \n  chunk_output_type: console\nbibliography: references.bib\n---\n\n\n# We will discuss\n\n-   What supervised learning is.\n-   Data splitting.\n-   How to evaluate classification models.\n-   How to put together a minimum working example of supervised learning with KNN classifier.\n\n## What is supervised learning\n\n*Definition*\n\n<br>\n\n\n```{mermaid}\nflowchart TD\n  A(Machine learning) --> B(unsupervised learning)\n  A --> C(supervised learning)\n```\n\n\n<br>\n\n::: incremental\n-   Supervised learning can be used for **classification** and **regression**.\n:::\n\n## What is supervised learning?\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/supervised-02.png)\n:::\n:::\n\n\n-   In supervised learning we are using sample **labels** to **train** (build) a model.\n-   We then use the trained model for **interpretation** and **prediction**.\n\n## What is supervised learning?\n\n*Definition* <br>\n\n::: incremental\n-   **Training** a model means selecting the best values for the model attributes (algorithm parameters) that allow linking the input data with the desired output task (classification or regression).\n-   Common supervised machine learning algorithms include:\n    -   K-Nearest Neighbor (KNN), Support Vector Machines (SVM), Random Forest (RF) or Artificial Neural Networks (ANN).\n-   Many of the ML methods can be implemented to work both for classifying samples and forecasting numeric outcome.\n:::\n\n## Supervised learning\n\n*Outline* \n\n<br>\n\nCommon steps:\n\n-   deciding on the task: classification or regression\n-   splitting data to keep part of data for training and part for testing\n-   selecting supervised machine learning algorithms\n-   deciding on the training strategy, i.e. which performance metrics to use\n-   running feature engineering\n-   performing feature selection\n\n## Supervised learning\n\n*Outline* \n\n<br>\n\nCommon steps:\n\n-   deciding on the task: **classification** or regression\n-   **splitting data** to keep part of data for training and part for testing\n-   selecting supervised machine learning algorithms, e.g. **k-nearest neighbor**\n-   deciding on the training strategy, i.e. which **performance metrics** to use\n-   running feature engineering\n-   performing feature selection\n\n<!-- ## Supervised learning {.scrollable} -->\n\n<!-- *Outline* <br> -->\n\n<!-- The diagram below shows a basic strategy on how to train KNN for classification, given a data set with $n$ samples, $p$ variables and $y$ categorical outcome -->\n\n<!-- ```{mermaid} -->\n\n<!-- flowchart TD -->\n<!--   A([data]) -. split data \\n e.g. basic, stratified, grouped -.-> B([non-test set]) -->\n<!--   A([data]) -.-> C([test set]) -->\n<!--   B -.-> D(choose algorithm \\n e.g. KNN) -->\n<!--   D -.-> E(choose evaluation metric \\n e.g. overall accuracy) -->\n<!--   E -.-> F(feature engineering & selection) -->\n<!--   F -.-> G(prepare parameter space, e.g. odd k-values from 3 to 30) -->\n<!--   G -. split non-test -.-> H([train set & validation set]) -->\n<!--   H -.-> J(fit model on train set) -->\n<!--   J -.-> K(collect evaluation metric on validation set) -->\n<!--   K -.-> L{all values checked? \\n e.g. k more than 30} -->\n<!--   L -. No .-> J -->\n<!--   L -. Yes .-> M(select best parameter values) -->\n<!--   M -.-> N(fit model on all non-test data) -->\n<!--   N -.-> O(assess model on test data) -->\n<!--   C -.-> O -->\n\n<!-- ``` -->\n\n<!-- ## Supervised learning -->\n\n<!-- *Outline* <br> -->\n\n<!-- Before we see how this training may look like in `R`, let's talk more about -->\n\n<!-- -   **KNN**, K-nearest neighbor algorithm -->\n<!-- -   **data splitting** and -->\n<!-- -   **performance metrics** useful for evaluating models -->\n\n# Classification\n\n\n## Classification\n\n<br>\n\n*Definition* <br>\n\n-   Classification methods are algorithms used to categorize objects.\n-   Let's for each observations $i$ collect pair of information $\\{\\mathbf{x_i}, g_i\\}$\n-   where $\\{\\mathbf{x_i}\\}$ is a set of exploratory variables e.g. a gene expression data\n-   and $g_i \\in \\{1, \\dots, G\\}$ is the class label for each observation (known), e.g. cancer stage I, II, III or IV\n-   Then we want to find a **classification rule** $f(.)$ (model) such that $$f(\\mathbf{x_i})=g_i$$\n\n# KNN (algorithm)\n\n## KNN\n\n*example of a classification algorithm*\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n\n\n\n::: r-stack\n![](session-supervise-presentation_files/figure-revealjs/fig-knn-00-1.png){.fragment width=\"700\" height=\"600\"}\n\n![](session-supervise-presentation_files/figure-revealjs/fig-knn-01-1.png){.fragment width=\"700\" height=\"600\"}\n\n![](session-supervise-presentation_files/figure-revealjs/fig-knn-02-1.png){.fragment width=\"700\" height=\"600\"}\n\n![](session-supervise-presentation_files/figure-revealjs/fig-knn-03-1.png){.fragment width=\"700\" height=\"600\"}\n:::\n\n## KNN\n\n*example of a classification algorithm*\n\n\n\n\n\n\n\n\n\n\n\n::: r-stack\n![](session-supervise-presentation_files/figure-revealjs/fig-knn-10-1.png){.fragment width=\"700\" height=\"600\"}\n\n![](session-supervise-presentation_files/figure-revealjs/fig-knn-20-1.png){.fragment width=\"700\" height=\"600\"}\n\n![](session-supervise-presentation_files/figure-revealjs/fig-knn-30-1.png){.fragment width=\"700\" height=\"600\"}\n\n![](session-supervise-presentation_files/figure-revealjs/fig-knn-40-1.png){.fragment width=\"700\" height=\"600\"}\n:::\n\n## KNN\n\n<br>\n\n*Algorithm* <br>\n\n\n-   Decide on the value of $k$.\n-   Calculate the distance between the query-instance (observations for new sample) and all the training samples.\n-   Sort the distances and determine the nearest neighbors based on the $k$-th minimum distance.\n-   Gather the categories of the nearest neighbors.\n-   Use majority voting of the categories of the nearest neighbors as the prediction value for the new sample.\n\n# Data splitting\n\n## Data splitting\n\n<br>\n\n*Why* <br>\n\n-   Part of the issue of fitting complex models to data is that the model can be continually tweaked to adapt as well as possible.\n-   As a result the trained model may not generalize well on future data due to the added complexity that only works for a given unique data set, leading to **overfitting**.\n-   To deal with overconfident estimation of future performance we can implement various data splitting strategies.\n\n## Data splitting\n\n*train, validation & test sets*\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/data-split-02.png){fig-align='center' width=100%}\n:::\n:::\n\n\n-   **Training data**: this is data used to fit (train) the classification or regression model, i.e. derive the classification rule.\n-   **Validation data**: this is data used to select which parameters or types of model perform best, i.e. to validate the performance of model parameters.\n-   **Test data**: this data is used to give an estimate of future prediction performance for the model and parameters chosen.\n-   Common split strategies include 50%/25%/25% and 33%/33%/33% splits for training/validation/test respectively\n\n## Data splitting\n\n*cross validation & repeated cross validation*\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](figures/data-split-kfolds-02.png){fig-align='center' width=100%}\n:::\n:::\n\n\n-   In **k-fold cross-validation** we split data into $k$ roughly equal-sized parts.\n-   We start by setting the validation data to be the first set of data and the training data to be all other sets.\n-   We estimate the validation error rate / correct classification rate for the split.\n-   We then repeat the process $k-1$ times, each time with a different part of the data set to be the validation data and the remainder being the training data.\n-   We finish with $k$ different error or correct classification rates.\n-   In this way, every data point has its class membership predicted once.\n-   The final reported error rate is usually the average of $k$ error rates.\n\n## Data splitting\n\n*Leave-one-out cross-validation* <br>\n\n-   Leave-one-out cross-validation is a special case of cross-validation where the number of folds equals the number of instances in the data set.\n\n\n::: {.cell layout-align=\"center\" fig-cap-location='margin'}\n::: {.cell-output-display}\n![Example of LOOCV, leave-one-out cross validation](figures/data-split-loocv-02.png){#fig-data-split-loocv fig-align='center' width=100%}\n:::\n:::\n\n\n<!-- ## Performance metrics -->\n\n<!-- *Evaluating classification* <br> -->\n\n<!-- -   To train the model we need some way of evaluating how well it works so we know how to tune the model parameters, e.g. change the value of $k$ in KNN. -->\n<!-- -   There are a few measures being used that involve looking at the truth (labels) and comparing it to what was predicted by the model. -->\n<!-- -   Common measures include: correct (overall) classification rate, missclassification rate, class specific rates, cross classification tables, sensitivity and specificity and ROC curves. -->\n\n# Performance metrics\n## Evaluating classification\n\n<br> <br> **Correct (miss)classification rate**\n\n-   The simplest way to evaluate in which we count for all the $n$ predictions how many times we got the classification right. $$Correct\\; Classifcation \\; Rate = \\frac{\\sum_{i=1}^{n}1[f(x_i)=g_i]}{n}$$ where $1[]$ is an indicator function equal to 1 if the statement in the bracket is true and 0 otherwise\n\n**Missclassification Rate**\n\nMissclassification Rate = 1 - Correct Classification Rate\n\n## Evaluating classification {.smaller}\n\n<br>\n\n**Confusion matrix**\n\nConfusion matrix allows us to compare between actual and predicted values. It is a N x N matrix, where N is the number of classes.\n\n|                     | Predicted Positive  | Predicted Negative  |\n|---------------------|---------------------|---------------------|\n| **Actual Positive** | True Positive (TP)  | False Negative (FN) |\n| **Actual Negative** | False Positive (FP) | True Negative (TN)  |\n\n-   **Accuracy**: measures the proportion of correctly classified samples over the total number of samples. $$ACC = \\frac{TP+TN}{TP+TN+FP+FN}$$\n\n-   **Sensitivity**: measures the proportion of true positives over all actual positive samples, i.e. how well the classifier is able to detect positive samples. It is also known as **true positive rate** and **recall**. $$TPR = \\frac{TP}{TP + FN}$$\n\n-   **Specificity**: measures the proportion of true negatives over all actual negative samples, i.e. how well the classifier is able to avoid false negatives. It is also known as **true negative rate** and **selectivity**. $$TNR = \\frac{TN}{TN+FP}$$\n\n-   **Precision**: measures the proportion of true positives over all positive predictions made by the classifier, i.e. how well the classifier is able to avoid false positives. It is also known as **positive predictive value**. $$PPV = \\frac{TP}{TP + FP}$$\n\n<!-- ## Performance metrics -->\n\n<!-- *Evaluating regression* <br> -->\n\n<!-- ::: incremental -->\n\n<!-- -   The idea of using data splits to train the model holds for fitting regression models. We can use data splits to train and assess regression models. -->\n\n<!-- -   For instance thinking back about the regression examples we have seen in previous section, we could try to find the best regression model to predict BMI given all other variables in the diabetes data set such as age, waist or cholesterol measurements. -->\n\n<!-- -   In the next section we will also learn about regularized regression where a penalty term is added to improve the generalization of a regression model; the penalty term(s) is optimized during the training of the model. -->\n\n<!-- ::: -->\n\n<!-- ## Evaluating regression {.smaller} -->\n\n<!-- <br> -->\n\n<!-- -   **R-squared**: As seen in the linear regression session. $$ -->\n\n<!--     R^2=1-\\frac{RSS}{TSS} = 1 - \\frac{\\sum_{i=1}^{n}(y_i - \\hat{y_i})^2}{\\sum_{i=1}^{n}(y_i - \\bar{y})^2} -->\n\n<!--     $$ -->\n\n<!-- -   **Adjusted R-squared**: seen before $$ -->\n\n<!--     R_{adj}^2=1-\\frac{RSS}{TSS}\\frac{n-1}{n-p-1} = 1 - \\frac{\\sum_{i=1}^{n}(y_i - \\hat{y_i})^2}{\\sum_{i=1}^{n}(y_i - \\bar{y})^2}\\frac{n-1}{n-p-1} -->\n\n<!--     $$ -->\n\n<!-- -   **Mean Squared Error (MSE)**: average squared difference between the predicted values and the actual values. $$MSE = \\frac{1}{N}\\sum_{i=1}^{N}({y_i}-\\hat{y}_i)^2$$ -->\n\n<!-- -   **Root Mean Squared Error (RMSE)**: square root of the MSE $$RMSE = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}({y_i}-\\hat{y}_i)^2}$$ -->\n\n<!-- -   **MAE**: average absolute difference between the predicted values and the actual values $$MAE = \\frac{1}{N}\\sum_{i=1}^{N}|{y_i}-\\hat{y}_i|$$ -->\n\n<!-- -   **Mean Absolute Percentage Error (MAPE)**: average percentage difference between the predicted values and the actual values. -->\n\n## Live demo\n\n*KNN model for classification*\n",
    "supporting": [
      "session-supervise-presentation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}